# Cpp
Code in C++ This code helps people to understand how their investments will grow. A simple code that helps with math that no one wants to do to test how much they will make off an investment over a certain period of time with or without monthly deposits. I love how readable the result of this code is. It breaks down year by year exactly how much your investment grows both with and without monthly deposits. Not only that but it shows the end of year income for each year basically showing how much passive income was gained that year. Honestly, I could have made this code prettier. While it gets the job done and is incredibly readable presentation wise it is very bare bones. The most challenging part was absolutely getting the math to work as intended. I was able to overcome this by focusing hard on pemdas and remembering my order of operations. By making the code itself readable and following industry best practices this made all the difference in making my math work. I could easily go back and identify any hiccups that my code had without tearing my hair out. This style of coding will be exceptional practice for moving forward and creating more code. Making the code readable will assist all future projects. Anyone editing my code should be able to easily identify what parts do what and change them to be better.

Interpreting user needs starts with understanding what problem they're actually trying to solve. For this investment calculator, users needed to see how their money grows over time, but more specifically they needed to compare scenarios with and without monthly deposits and understand their passive income year by year. I implemented this by breaking down the problem into concrete features and making sure the output clearly showed what users actually cared about. Creating user stories would have helped tremendously here. Instead of just thinking "build a calculator," I could have written stories like "As an investor, I want to see year-by-year growth so that I can understand compound interest over time" or "As a beginner, I want to compare scenarios with and without deposits so I can decide if regular contributions are worth it." User stories keep you focused on delivering value and solving real problems rather than just building features. They give you clear acceptance criteria through the "so that" clause, which defines when you're actually done. Moving forward, I'll use user stories to prioritize work and make sure I'm building what users actually need.

My approach to developing programs is pretty straightforward—understand the problem first, break it into smaller manageable pieces, write code that's readable and maintainable, and test as I go. For this calculator, I tackled the basic interest calculation first, then added monthly deposits, then focused on making the output readable. Looking back, this was actually iterative development without me realizing it. The Agile processes I hope to incorporate into future work include truly iterative development where I deliver working increments instead of trying to build everything at once. I want to get continuous feedback from users instead of waiting until the end to find out I built something wrong. Writing user stories will keep me focused on value delivery. I also want to do retrospectives after projects to reflect on what worked well and what could improve—just like I'm doing now by acknowledging this code could be prettier. Test-driven thinking will help me design better from the start. And refactoring should be continuous, not something I put off. Agile's "make it work, then make it better" philosophy fits perfectly with how I already think about code.

Being a good team member in software development means several things. First, writing readable code like I did here isn't just for me—it's for anyone who has to work with my code later. When teammates can easily understand what I built, collaboration becomes way easier. Following best practices and coding standards keeps the codebase consistent so the whole team can move faster. Good communication is huge—sharing blockers early, asking for help when stuck, and offering assistance to others. Being open to feedback through code reviews is essential because that's how we all get better. Documenting decisions and explaining why certain approaches were chosen helps future developers understand the code's evolution. Respecting others' time by writing clean, tested code means code reviews go faster and integration is smoother. And continuous learning matters because technology changes constantly—good team members stay current and share knowledge. In the context of team roles, being a good team member means doing your part well whether you're the developer writing clean code, the tester ensuring quality, the Product Owner providing clear requirements, or the Scrum Master facilitating collaboration. Everyone contributes uniquely to team success.
